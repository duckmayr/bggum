# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' The Four Parameter Beta Distribution
#'
#' Provides probability density, cumulative distribution, quantile, and random
#' number generating functions for the four parameter beta distribution.
#'
#' @param x,q A numeric vector of quantiles
#' @param p A numeric vector of probabilities
#' @param n The number of observations to generate
#' @param shape1 Shape 1
#' @param shape2 Shape 2
#' @param a The lowest possible value of the distribution
#' @param b The highest possible value of the distribution
#'
#' @return \code{d4beta} gives gives the density, \code{p4beta} gives the
#'   distribution function, \code{q4beta} gives the quantile function, and
#'   \code{r4beta} generates random numbers from the distribution.
#'
#' @name Four Parameter Beta
#' @rdname fourParamBeta
NULL

#' @rdname fourParamBeta
#' @export
d4beta <- function(x, shape1, shape2, a, b) {
    .Call('_ggumR_d4beta', PACKAGE = 'ggumR', x, shape1, shape2, a, b)
}

#' @rdname fourParamBeta
#' @export
p4beta <- function(q, shape1, shape2, a, b) {
    .Call('_ggumR_p4beta', PACKAGE = 'ggumR', q, shape1, shape2, a, b)
}

#' @rdname fourParamBeta
#' @export
q4beta <- function(p, shape1, shape2, a, b) {
    .Call('_ggumR_q4beta', PACKAGE = 'ggumR', p, shape1, shape2, a, b)
}

#' @rdname fourParamBeta
#' @export
r4beta <- function(n, shape1, shape2, a, b) {
    .Call('_ggumR_r4beta', PACKAGE = 'ggumR', n, shape1, shape2, a, b)
}

d_4beta <- function(x, shape1, shape2, a, b) {
    .Call('_ggumR_d_4beta', PACKAGE = 'ggumR', x, shape1, shape2, a, b)
}

r_4beta <- function(shape1, shape2, a, b) {
    .Call('_ggumR_r_4beta', PACKAGE = 'ggumR', shape1, shape2, a, b)
}

#' GGUM acceptance
#'
#' Determines a new value for the parameters used in the MCMC algorithm
#' for the GGUM.
#' 
#' Given a current value \code{cv} for the parameter of interest,
#' as well as the responses and other parameters relevant to estimating the
#' parameter of interest, a new proposal for the parameter is generated
#' and accepted with probability
#' \deqn{\min \{1, \frac{\mathcal{L}(X|\theta^*)\pi(\theta^*)}{%
#' \mathcal{L}(X|\theta)\pi(\theta)}\}}{%
#' min {1, (L(X|\theta*)\pi(\theta*) / (L(X|\theta)\pi(\theta))}}
#' where \eqn{\theta^*}{\theta*} is the proposed value,
#' \eqn{\theta} is the current value, \eqn{\pi(\cdot)}{\pi(.)}
#' is the prior probability a parameter takes a value, and
#' \eqn{\mathcal{L}(X|\cdot)}{L(X|.)} is the likelihood of observing the
#' responses given a parameter value.
#'
#' @section Warning:
#' For \code{acceptanceTau}, the tau vector is indexed beginning with 0!
#' When using this function, you must supply an index of one less than the
#' index you would supply if subsetting in \code{R}.
#'
#' @param responses A numeric vector giving the responses by the respondent
#'   or item of interest; for \code{acceptanceTheta} this would be one row of
#'   the response matrix, while for \code{acceptanceAlpha},
#'   \code{acceptanceDelta}, or \code{acceptanceTau} this would be one column
#'   of the response matrix
#' @param cv The current value of the paramenter of interest
#' @param thetas The numeric vector of current values of the items' theta
#'   parameters
#' @param alphas The numeric vector of current values of the items' alpha
#'   parameters
#' @param alpha The alpha parameter for the item of interest (for
#'   \code{acceptanceDelta} and \code{acceptanceTau}, there is only one
#'   alpha needed for the calculations)
#' @param deltas The numeric vector of current values of the items' delta
#'   parameters
#' @param delta The delta parameter for the item of interest (for
#'   \code{acceptanceAlpha} and \code{acceptanceTau}, there is only one
#'   delta needed for the calculations)
#' @param taus The list or vector of current values of the items' tau
#'   parameters (for \code{acceptanceTheta} this is a list because there are
#'   multiple tau vectors that must be used, but for the other acceptance
#'   functions, only one numeric vector is needed)
#' @param SD The sigma parameter to be used for the proposal distribution
#' @param k For \code{acceptanceTau}, an integer giving the index
#'   (NOTE: the index must be specified as the vector would be indexed in
#'   C++; i.e., the R index - 1 since C++ begins indexing at 0) in the
#'   tau vector of the tau parameter of interest.
#'
#' @return If the acceptance ratio is greater than one or greater than a
#'   number randomly generated from the standard uniform distribution,
#'   the proposed value is returned; otherwise, the \code{cv} is returned.
#'
#' @name GGUM MCMC Proposal Acceptance
#' @aliases acceptanceTheta, acceptanceAlpha, acceptanceDelta, acceptanceTau,
#'   acceptance
#' @rdname acceptance
#' @export
acceptanceTheta <- function(responses, cv, alphas, deltas, taus, SD) {
    .Call('_ggumR_acceptanceTheta', PACKAGE = 'ggumR', responses, cv, alphas, deltas, taus, SD)
}

acceptanceThetaNeg <- function(responses, cv, alphas, deltas, taus, SD) {
    .Call('_ggumR_acceptanceThetaNeg', PACKAGE = 'ggumR', responses, cv, alphas, deltas, taus, SD)
}

acceptanceThetaPos <- function(responses, cv, alphas, deltas, taus, SD) {
    .Call('_ggumR_acceptanceThetaPos', PACKAGE = 'ggumR', responses, cv, alphas, deltas, taus, SD)
}

#' @rdname acceptance
#' @export
acceptanceAlpha <- function(responses, thetas, cv, delta, taus, SD) {
    .Call('_ggumR_acceptanceAlpha', PACKAGE = 'ggumR', responses, thetas, cv, delta, taus, SD)
}

#' @rdname acceptance
#' @export
acceptanceDelta <- function(responses, thetas, alpha, cv, taus, SD) {
    .Call('_ggumR_acceptanceDelta', PACKAGE = 'ggumR', responses, thetas, alpha, cv, taus, SD)
}

#' @rdname acceptance
#' @export
acceptanceTau <- function(k, responses, thetas, alpha, delta, taus, SD) {
    .Call('_ggumR_acceptanceTau', PACKAGE = 'ggumR', k, responses, thetas, alpha, delta, taus, SD)
}

#' GGUM getPrior
#' 
#' Get the prior probability of values for the GGUM parameters theta, alpha,
#' delta, and tau.
#'
#' Following de la Torre et al (2006), we use the following prior
#' distributions for MCMC estimation of GGUM parameters:
#' \itemize{
#'   \item Theta -- The standard normal
#'   \item Alpha -- A four parameter beta distribution, with shape parameters
#'     1.5, 1.5, minimum value 0.25, and maximum value 4
#'   \item Delta -- A four parameter beta distribution, with shape parameters
#'     2, 2, minimum value -5, and maximum value 5
#'   \item Tau -- A four parameter beta distribution, with shape parameters
#'     2, 2, minimum value -6, and maximum value 6
#' }
#' 
#' @param cv A numeric vector of length one; the current value of the
#'   parameter of interest
#' 
#' @return A numeric vector of length one. The prior probability of observing
#'   \code{cv} for the paramenter of interest.
#'
#' @references de la Torre, Jimmy, Stephen Stark, and Oleksandr S.
#'   Chernyshenko. 2006. ``Markov Chain Monte Carlo Estimation of Item
#'   Parameters for the Generalized Graded Unfolding Model." \emph{Applied
#'   Psychological Measurement} 30(3): 216--232.
#'
#' @name GGUM Priors
#' @aliases getPriorTheta, getPriorAlpha, getPriorDelta, getPriorTau, getPrior
#' @rdname getPrior
#' @export
getPriorTheta <- function(cv) {
    .Call('_ggumR_getPriorTheta', PACKAGE = 'ggumR', cv)
}

#' @rdname getPrior
#' @export
getPriorAlpha <- function(cv) {
    .Call('_ggumR_getPriorAlpha', PACKAGE = 'ggumR', cv)
}

#' @rdname getPrior
#' @export
getPriorDelta <- function(cv) {
    .Call('_ggumR_getPriorDelta', PACKAGE = 'ggumR', cv)
}

#' @rdname getPrior
#' @export
getPriorTaus <- function(cv) {
    .Call('_ggumR_getPriorTaus', PACKAGE = 'ggumR', cv)
}

#' GGUM Log Likelihood
#' 
#' Calculate the log likelihood of data for the GGUM given parameter values.
#'
#' This function calculates the log likelihood of a \bold{vector} of
#' responses given values for the parameters relevant to the responses.
#' This could be all of a respondent \eqn{i}'s responses to every item \eqn{j},
#' or all respondents' responses to an item \eqn{j}. We calculate likelihood
#' of vectors rather than the likelihood of the entire response matrix since
#' when computing acceptance ratios for the MCMC algorithm, we divide products
#' of probabilities, most of which will cancel out -- thus, we only ever need
#' the likelihood of one vector at any given time.
#' 
#' @param theta For \code{loglikelihoodRow}, a numeric vector of length one
#'   giving the individual's latent trait parameter
#' @param responses For \code{loglikelihoodRow}, a numeric vector of length
#'   length n (the number of items) giving the option chosen by the individual
#'   for each item j; for \code{loglikelihoodCol}, a numeric vector of length
#'   N (the number of respondents), giving the option chosen by each individual
#'   i to the item
#' @param alphas A numeric vector of length n; each element of the vector is an
#'   item's discrimination parameter
#' @param deltas A numeric vector of length n; each element of the vector is an
#'   item's location parameter
#' @param taus For \code{loglikelihoodRow}, a list of numeric vectors where
#'   each list element j is a numeric vector of threshold parameters for item
#'   j's options (where the first element of the vector should be zero);
#'   for \code{loglikelihoodCol}, this is only the numeric vector of threshold
#'   parameters for the item of interest
#' @param thetas A numeric vector of length N, each each element of which is
#'   an individual's latent trait parameter
#' @param alpha A numeric vector of length one giving the item's
#'   discrimination parameter
#' @param delta A numeric vector of length one giving the item's
#'   location parameter
#'
#' @return The (log) likelihood of the vector of interest.
#' @name ggumLogLikelihood
#' @aliases loglikelihoodRow, loglikelihoodCol, ggumLogLikelihood
#' @rdname ggumLogLikelihood
#' @export
loglikelihoodRow <- function(responses, theta, alphas, deltas, taus) {
    .Call('_ggumR_loglikelihoodRow', PACKAGE = 'ggumR', responses, theta, alphas, deltas, taus)
}

#' @rdname ggumLogLikelihood
#' @export
loglikelihoodCol <- function(responses, thetas, alpha, delta, taus) {
    .Call('_ggumR_loglikelihoodCol', PACKAGE = 'ggumR', responses, thetas, alpha, delta, taus)
}

#' GGUM MC3
#'
#' Metropolis Coupled Markov Chain Monte Carlo Sampling for the GGUM
#'
#' @param data A numeric matrix giving the individuals' responses
#' @param iters A vector of length one giving the number of iterations
#' @param N The number of chains
#' @param W The period by which to attempt chain swaps; e.g. if W = 100,
#'   a state swap will be proposed between two randomly selected chains
#'   every 100 iterations
#' @param Temps An optional provision of the temperatures for the chains;
#'   if not provided, each temperature T_t for t < N is given by
#'   T_{t+1} * (t + 1), and T_N = 1.
#'
#' @return A numeric matrix giving the parameter values at each iteration
#'   for the cold chain
#' @export
ggumMC3 <- function(data, iters, r_one, r_two, N, W, Temps = NULL) {
    .Call('_ggumR_ggumMC3', PACKAGE = 'ggumR', data, iters, r_one, r_two, N, W, Temps)
}

#' GGUM MCMC Sampler
#'
#' MCMC sampler for the generalized graded unfolding model (GGUM), utilizing
#' a Metropolis-Hastings algorithm
#'
#' \code{ggumMCMC} provides \code{R} implementation of an MCMC sampler for
#' the GGUM, based heavily on the algorithm given in de la Torre et al (2006);
#' though the package allows parameter estimation from \code{R},
#' the functions are actually written in \code{C++} to allow for reasonable
#' execution time.
#' Our sampler creates random ititial values for the parameters of the model,
#' according to their prior distributions (see \code{\link{getPrior}}).
#' Then, for the first 1000 iterations, the sampler, one parameter at a time,
#' will make a proposal from the truncated location-scale T distribution
#' specified in \code{\link{proposer}} where \eqn{SD = 1}, and accept the
#' proposal probabilistically according to the ratio in
#' \code{\link{acceptance}}. For the remainder of the iterations, the same
#' process is followed, but the \eqn{\sigma} parameter for the proposal
#' density is the standard deviation of the previous 5000 values of the
#' parameter. A matrix is returned giving the value of every parameter at
#' every iteration.
#'
#' @section Warning:
#' Typically, up to 5000 iterations are needed for convergence,
#' and specifying less than 5000 iterations will cause an error.
#' Also, theta and delta parameters often have multi-modal posterior
#' distributions, and in some cases chains may converge to the wrong
#' mode for both parameters; in other words, the questions with the most
#' negative delta parameters will be estimated as having the most positive
#' delta parameters and vice versa, but only if the same happens with
#' the theta parameters. Future package updates will provide a way to
#' specify the expected sign of at least one theta and delta parameter
#' to prevent this occurrence.
#'
#' @param responseMatrix A numeric matrix giving the response by each
#'   respondent to each item
#' @param Kvector A numeric vector of length m (the number of items), each
#'   element j of which gives the number of options (K) for item j
#' @param iterations A numeric vector of length one; the number of iterations
#'   (NOTE: \code{iterations} should be at least 10000, and preferably around
#'   25000, though only values of 5000 or less will cause an error)
#' @param low A numeric vector of length one giving the row number for a
#'   respondent whose theta parameter will be restricted to be negative
#' @param high A numeric vector of length one giving the row number for a
#'   respondent whose theta parameter will be restricted to be positive
#'
#' @return A chain matrix; a numeric matrix with \code{iterations} rows and
#'   one column for every parameter of the model, so that each element of the
#'   matrix gives the value of a parameter for a particular iteration of the
#'   MCMC algorithm.
#'
#' @seealso \code{\link{ggumProbability}}, \code{\link{acceptance}},
#'   \code{\link{getPrior}}, \code{\link{proposer}}
#'
#' @references Roberts, James S., John R. Donoghue, and James E. Laughlin.
#'   2000. ``A General Item Response Theory Model for Unfolding
#'   Unidimensional Polytomous Responses." \emph{Applied Psychological
#'   Measurement} 24(1): 3--32.
#' @references de la Torre, Jimmy, Stephen Stark, and Oleksandr S.
#'   Chernyshenko. 2006. ``Markov Chain Monte Carlo Estimation of Item
#'   Parameters for the Generalized Graded Unfolding Model." \emph{Applied
#'   Psychological Measurement} 30(3): 216--232.
#'   algorithm
#' @export
ggumMCMC <- function(responseMatrix, Kvector, iterations, low, high) {
    .Call('_ggumR_ggumMCMC', PACKAGE = 'ggumR', responseMatrix, Kvector, iterations, low, high)
}

#' GGUM Probability Function
#'
#' Calculate the probability of a response according to the GGUM
#' 
#' The General Graded Unfolding Model (GGUM) is an item response model
#' designed to consider the possibility of disagreement for opposite reasons.
#' This function gives the probability of a respondent's response to a test
#' item given item and respondent parameters. The user can calculate the
#' probability of one particular response or for any number of the possible
#' responses to the item (see the \code{k} parameter described below).
#'
#' The probability that respondent \eqn{i} chooses option \eqn{k} for item
#' \eqn{j} is given by
#' \deqn{\frac{\exp (\alpha_j [k (\theta_i - \delta_j) -
#' \sum_{m=0}^k \tau_{jm}]) + \exp (\alpha_j [(2K - k - 1)
#' (\theta_i - \delta_j) - \sum_{m=0}^k \tau_{jm}])}{%
#' \sum_{l=0}^{K-1} [\exp (\alpha_j [l (\theta_i - \delta_j) -
#' \sum_{m=0}^l \tau_{jm}]) + \exp (\alpha_j [(2K - l - 1)
#' (\theta_i - \delta_j) - \sum_{m=0}^l \tau_{jm}])]}}{%
#' (exp(\alpha_j [k(\theta_i-\delta_j) - 
#' \Sigma_{m=0}^k \tau_{jm}]) + exp(\alpha_j [(2K - k - 1)
#' (\theta_i - \delta_j) - \Sigma_{m=0}^k \tau_{jm}])) /
#' (\Sigma_{l=0}^{K-1} [exp (\alpha_j [l (\theta_i - \delta_j) -
#' \Sigma_{m=0}^l \tau_{jm}]) + exp (\alpha_j [(2K - l - 1)
#' (\theta_i - \delta_j) - \Sigma_{m=0}^l \tau_{jm}])])},
#' where \eqn{\theta_i} is \eqn{i}'s latent trait parameter,
#' \eqn{\alpha_j} is the item's discrimination paramter,
#' \eqn{\delta_j} is the item's location paramter,
#' \eqn{\tau_{j0}, \ldots, \tau_{j(K-1)}} are the options' threshold
#' parameters, and \eqn{\tau_{j0}} is 0,
#' \eqn{K} is the number of options for item \eqn{j}, and
#' the options are indexed by \eqn{k = 0, \ldots, K-1}.
#' 
#' @param k A numeric vector giving the item(s) for which response
#'   probability should be calculated
#' @param theta A numeric vector of length one giving the respondent's latent
#'   trait score
#' @param alpha A numeric vector of length one giving the item's
#'   discrimination parameter
#' @param delta A numeric vector of length one giving the item's location
#'   parameter
#' @param tau A numeric vector of length K (the number of possible responses)
#'   giving the options' threshold parameters; the first element of \code{tau}
#'   should be zero
#'
#' @return A numeric vector the same length of \code{k} giving the response
#'   probabilities
#'
#' @references Roberts, James S., John R. Donoghue, and James E. Laughlin.
#'   2000. ``A General Item Response Theory Model for Unfolding
#'   Unidimensional Polytomous Responses." \emph{Applied Psychological
#'   Measurement} 24(1): 3--32.
#' @references de la Torre, Jimmy, Stephen Stark, and Oleksandr S.
#'   Chernyshenko. 2006. ``Markov Chain Monte Carlo Estimation of Item
#'   Parameters for the Generalized Graded Unfolding Model." \emph{Applied
#'   Psychological Measurement} 30(3): 216--232.
#'
#' @rdname ggumProbability
#' @export
ggumProbability <- function(k, theta, alpha, delta, tau) {
    .Call('_ggumR_ggumProbability', PACKAGE = 'ggumR', k, theta, alpha, delta, tau)
}

prob <- function(choice, th, a, d, t) {
    .Call('_ggumR_prob', PACKAGE = 'ggumR', choice, th, a, d, t)
}

probCol <- function(choices, thetas, a, d, t) {
    .Call('_ggumR_probCol', PACKAGE = 'ggumR', choices, thetas, a, d, t)
}

probRow <- function(choices, th, a, d, t) {
    .Call('_ggumR_probRow', PACKAGE = 'ggumR', choices, th, a, d, t)
}

#' The location-scale T distribution.
#'
#' Density, distribution function, quantile function, and random number
#' generation for the T distribution shifted by location parameter 'mu' and
#' scaled by 'sigma'.
#'
#' @param n A numeric vector of length one; the number of numbers to generate
#' @param x,q A numeric vector of the quantiles of interest
#' @param p A numeric vector of the probabilities of interest
#' @param df A numeric vector of length one; the degrees of freedom of the
#'   distribution
#' @param sigma A numeric vector of length one; the scale parameter
#' @param mu A numeric vector of length one; the shifting parameter
#'
#' @return 'dlst' gives the density, 'plst' gives the distribution function,
#'     'qlst' gives the quantile function, and 'rlst' generates random numbers
#'     from the distribution
#'     
#' @references Jackman, Simon. 2009. \emph{Bayesian Analysis for the Social
#'     Sciences}. Wiley. p. 507.
#'
#' @name Location-Scale T
#' @rdname scaledT-dist
NULL

#' @rdname scaledT-dist
#' @export
dlst <- function(x, df, mu, sigma) {
    .Call('_ggumR_dlst', PACKAGE = 'ggumR', x, df, mu, sigma)
}

#' @rdname scaledT-dist
#' @export
plst <- function(q, df, mu, sigma) {
    .Call('_ggumR_plst', PACKAGE = 'ggumR', q, df, mu, sigma)
}

#' @rdname scaledT-dist
#' @export
qlst <- function(p, df, mu, sigma) {
    .Call('_ggumR_qlst', PACKAGE = 'ggumR', p, df, mu, sigma)
}

#' @rdname scaledT-dist
#' @export
rlst <- function(n, df, mu, sigma) {
    .Call('_ggumR_rlst', PACKAGE = 'ggumR', n, df, mu, sigma)
}

d_lst <- function(x, df, mu, sigma) {
    .Call('_ggumR_d_lst', PACKAGE = 'ggumR', x, df, mu, sigma)
}

p_lst <- function(q, df, mu, sigma) {
    .Call('_ggumR_p_lst', PACKAGE = 'ggumR', q, df, mu, sigma)
}

r_lst <- function(df, mu, sigma) {
    .Call('_ggumR_r_lst', PACKAGE = 'ggumR', df, mu, sigma)
}

dhnormpos <- function(x) {
    .Call('_ggumR_dhnormpos', PACKAGE = 'ggumR', x)
}

dhnormneg <- function(x) {
    .Call('_ggumR_dhnormneg', PACKAGE = 'ggumR', x)
}

updateTheta <- function(cv, choices, a, d, t, temp) {
    .Call('_ggumR_updateTheta', PACKAGE = 'ggumR', cv, choices, a, d, t, temp)
}

updateThetaPos <- function(cv, choices, a, d, t, temp) {
    .Call('_ggumR_updateThetaPos', PACKAGE = 'ggumR', cv, choices, a, d, t, temp)
}

updateThetaNeg <- function(cv, choices, a, d, t, temp) {
    .Call('_ggumR_updateThetaNeg', PACKAGE = 'ggumR', cv, choices, a, d, t, temp)
}

updateAlpha <- function(cv, choices, th, d, t, temp) {
    .Call('_ggumR_updateAlpha', PACKAGE = 'ggumR', cv, choices, th, d, t, temp)
}

updateDelta <- function(cv, choices, th, a, t, temp) {
    .Call('_ggumR_updateDelta', PACKAGE = 'ggumR', cv, choices, th, a, t, temp)
}

updateTau <- function(k, choices, th, a, d, t, temp) {
    .Call('_ggumR_updateTau', PACKAGE = 'ggumR', k, choices, th, a, d, t, temp)
}

